import { DatabaseTable, PlayerIdentifier } from "@/generated/db";
import {
  RewardClaimResult,
  RewardConfig,
  RewardEligibilityResult,
} from "../types";
import { Q } from "@/db";
import { BalanceUtils } from "@/db/repositories/balance/utils";

/**
 * Abstract base class for all reward types
 *
 * Provides common functionality that all reward implementations share:
 * - Player identifier resolution (UUID, username, discordId -> UUID)
 * - Claim history retrieval from database
 * - Claim recording with metadata support
 * - Automatic currency conversion (storage <-> display format)
 *
 * All concrete reward types (DailyReward, WeeklyReward, etc.) must extend
 * this class and implement the abstract methods for their specific logic
 */
export abstract class BaseReward {
  /**
   * Initializes the base reward with configuration
   *
   * @param config - Reward configuration from REWARD_CONFIGS
   *
   * @protected - Available to subclasses
   */
  constructor(protected config: RewardConfig) {}

  /**
   * Resolves any player identifier format to a Minecraft UUID
   *
   * Accepts multiple input formats for flexibility:
   * - String UUID: "123e4567-e89b-12d3-a456-426614174000"
   * - Player object with minecraftUuid field
   * - Player object with discordId or minecraftUsername (queries database)
   * - Any PlayerIdentifier union type
   *
   * This allows calling code to use whatever identifier is most convenient
   * without worrying about format conversion.
   *
   * @param identifier - Player in any accepted format
   * @returns Promise resolving to the player's Minecraft UUID
   * @throws Error if player not found in database (when using non-UUID identifiers)
   *
   * @protected - Only for use by subclass implementations
   *
   * @example
   * // All of these work:
   * await this.resolvePlayerUuid("123e4567-..."); // Direct UUID
   * await this.resolvePlayerUuid({ minecraftUuid: "123e4567-..." }); // Player object
   * await this.resolvePlayerUuid({ discordId: "987654321" }); // Discord lookup
   * await this.resolvePlayerUuid({ minecraftUsername: "Steve" }); // Username lookup
   */
  protected async resolvePlayerUuid(
    identifier: PlayerIdentifier,
  ): Promise<string> {
    if (typeof identifier === "string") return identifier;
    if ("minecraftUuid" in identifier && identifier.minecraftUuid) {
      return identifier.minecraftUuid;
    }
    const player = await Q.player.get(identifier);
    return player.minecraftUuid;
  }

  /**
   * Retrieves the most recent claim for this reward type by a player
   *
   * Queries the reward_claim table for the latest claim matching:
   * - Player UUID
   * - Reward type (daily, weekly, etc.)
   *
   * Sorted by claimed_at DESC to get the most recent first.
   *
   * Currency Conversion:
   * - Database stores amounts in smallest unit (e.g., 50 = 0.050)
   * - This method converts to display value using BalanceUtils
   * - Subclasses receive user-friendly decimal values
   *
   * @param playerUuid - Minecraft UUID of the player
   * @returns Promise resolving to last claim data or null if never claimed
   *          { claimedAt: Date, amount: number (display value) }
   *
   * @protected - Only for use by subclass implementations
   *
   * @example
   * const lastClaim = await this.getLastClaim(playerUuid);
   * if (lastClaim) {
   *   console.log(lastClaim.claimedAt); // Date(2025-01-24T10:30:00Z)
   *   console.log(lastClaim.amount); // 0.050 (converted from 50)
   * }
   */
  protected async getLastClaim(
    playerUuid: string,
  ): Promise<{ claimedAt: Date; amount: number } | null> {
    const claims = await Q.reward.claim.findAll(
      {
        playerMinecraftUuid: playerUuid,
        rewardType: this.config.type,
      },
      {
        limit: 1,
        orderBy: DatabaseTable.REWARD_CLAIM.CAMEL_FIELDS.CLAIMED_AT,
        orderDirection: "DESC",
      },
    );

    if (claims.length === 0) return null;

    return {
      claimedAt: claims[0].claimedAt,
      amount: BalanceUtils.fromStorage(claims[0].amount),
    };
  }

  /**
   * Records a reward claim in the database for audit trail
   *
   * Creates a new entry in the reward_claim table with:
   * - Player UUID (for tracking who claimed)
   * - Reward type (daily, weekly, etc.)
   * - Amount claimed (automatically converted to storage format)
   * - Timestamp (auto-generated by database)
   * - Optional metadata (custom data for special rewards)
   *
   * Currency Conversion:
   * - Input amount should be in display format (e.g., 0.050)
   * - Automatically converted to storage format (e.g., 50)
   * - Uses BalanceUtils for consistent precision (3 decimals)
   *
   * Used by subclasses after successfully crediting the player's balance
   * to maintain a complete history of all reward claims.
   *
   * @param playerUuid - Minecraft UUID of the player claiming
   * @param amount - Reward amount in display format (will be converted to storage)
   * @param metadata - Optional additional data (achievement ID, bonus multiplier, etc.)
   * @returns Promise resolving when claim is recorded
   *
   * @protected - Only for use by subclass implementations
   *
   * @example
   * // Record a daily reward claim
   * await this.recordClaim(playerUuid, 0.050);
   *
   * @example
   * // Record with metadata
   * await this.recordClaim(playerUuid, 0.100, {
   *   bonusMultiplier: 2,
   *   streakDays: 7
   * });
   */
  protected async recordClaim(
    playerUuid: string,
    amount: number,
    metadata?: Record<string, any>,
  ): Promise<void> {
    await Q.reward.claim.create({
      playerMinecraftUuid: playerUuid,
      rewardType: this.config.type,
      amount: BalanceUtils.toStorage(amount),
      metadata: metadata || {},
    });
  }

  /**
   * Checks if a player is eligible to claim this reward
   *
   * Must be implemented by each reward type to define their specific
   * eligibility rules. Examples:
   *
   * - DailyReward: Check if reset hour has passed since last claim
   * - WeeklyReward: Check if 7 days have passed since last claim
   * - AchievementReward: Check if achievement is completed and not already claimed
   *
   * @param identifier - Player identifier (any accepted format)
   * @returns Promise resolving to eligibility result with:
   *          - eligible: boolean (can claim or not)
   *          - reason: string (why not eligible, if applicable)
   *          - nextClaimTime: Date (when they can claim next, if applicable)
   *          - lastClaimTime: Date (when they last claimed, if applicable)
   *
   * @abstract - Must be implemented by subclasses
   *
   * @example
   * async checkEligibility(identifier: PlayerIdentifier): Promise<RewardEligibilityResult> {
   *   const playerUuid = await this.resolvePlayerUuid(identifier);
   *   const lastClaim = await this.getLastClaim(playerUuid);
   *   // ... custom eligibility logic ...
   *   return { eligible: true };
   * }
   */
  abstract checkEligibility(
    identifier: PlayerIdentifier,
  ): Promise<RewardEligibilityResult>;

  /**
   * Claims the reward for a player
   *
   * Must be implemented by each reward type to define their specific
   * claim logic. Typical implementation pattern:
   *
   * 1. Check eligibility (using checkEligibility)
   * 2. Add currency to player balance (using balanceRepo)
   * 3. Record claim (using recordClaim)
   * 4. Calculate next claim time (using getNextClaimTime)
   * 5. Return success result
   *
   * All operations should be wrapped in error handling to ensure
   * graceful failures and consistent error messages.
   *
   * @param identifier - Player identifier (any accepted format)
   * @returns Promise resolving to claim result with:
   *          - success: boolean (claim succeeded or not)
   *          - amount: number (amount claimed, if successful)
   *          - newBalance: number (player's new balance, if successful)
   *          - nextClaimTime: Date (when they can claim again)
   *          - error: string (error message, if failed)
   *
   * @abstract - Must be implemented by subclasses
   *
   * @example
   * async claim(identifier: PlayerIdentifier): Promise<RewardClaimResult> {
   *   const playerUuid = await this.resolvePlayerUuid(identifier);
   *   const eligible = await this.checkEligibility(identifier);
   *   if (!eligible.eligible) {
   *     return { success: false, error: eligible.reason };
   *   }
   *   // ... add balance, record claim, etc. ...
   *   return { success: true, amount: this.config.amount, newBalance };
   * }
   */
  abstract claim(identifier: PlayerIdentifier): Promise<RewardClaimResult>;

  /**
   * Calculates when this reward can be claimed next
   *
   * Must be implemented by each reward type based on their reset schedule:
   *
   * - DailyReward: Next reset hour (e.g., midnight UTC)
   * - WeeklyReward: Same day/time next week
   * - MonthlyReward: Same day/time next month
   *
   * Used to inform players when they can claim again and for
   * eligibility checks.
   *
   * @param lastClaimTime - Timestamp of the player's last claim
   * @returns Date object representing when the reward can be claimed next
   *
   * @abstract - Must be implemented by subclasses
   *
   * @example
   * getNextClaimTime(lastClaimTime: Date): Date {
   *   const next = new Date(lastClaimTime);
   *   next.setUTCHours(this.config.resetHour, 0, 0, 0);
   *   if (next <= lastClaimTime) {
   *     next.setUTCDate(next.getUTCDate() + 1);
   *   }
   *   return next;
   * }
   */
  abstract getNextClaimTime(lastClaimTime: Date): Date;
}
